# 알고리즘

- [알고리즘](#알고리즘)
  - [알고리즘이란?](#알고리즘이란)
  - [알고리즘 분석](#알고리즘-분석)
  - [시간 복잡도](#시간-복잡도)
  - [점근성능](#점근성능)
  - [점근성능의 표기법](#점근성능의-표기법)
  - [순환 알고리즘의 성능 (재귀 : recursion)](#순환-알고리즘의-성능-재귀--recursion)
  - [분할정복 방법](#분할정복-방법)
    - [이진 탐색](#이진-탐색)
    - [퀵 정렬](#퀵-정렬)

## 알고리즘이란?

- 주어진 문제의 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 유한개의 일련의 명령을 순서적을 구성한 것

## 알고리즘 분석

알고리즘 분석의 기준은 다음과 같다

- 정확성 분석
  - 유효한 입력, 유한 시간 -> 정확한 결과 생성 여부
  - 다양한 수학적 기법을 사용해서 이론적인 증명이 필요
  - 현재 많이 알려진 알고리즘들은 이미 이론적으로 증명된 알고리즘임
- 효율성 분석
  - 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
  - 메모리 양 -> `공간 복잡도`(space complexity)
  - 정적 공간 + 동적 공간
  - 수행 시간 -> `시간 복잡도`(time complexity)

## 시간 복잡도

- `시간 복잡도` : 알고리즘의 단위 연산의 수행 횟수의 합
- 입력 크기를 n이라고 하여 입력 크기 n에 대한 함수 f(n)으로 표현된다
- 입력 데이터의 상태에 종속적이며 상태에 따라 수행 시간이 다음과 같이 분류됨
  - 평균 수행 시간
  - 최선 수행 시간
  - `최악 수행 시간` -> 최악의 수행 시간을 시간 복잡도로 사용함
- 시간 복잡도에 영향을 미치는 요인
  - 입력 크기
    - 입력으로 제공되는 데이터의 크기, 문제가 해결하려는 대상이 되는 개체의 개수
    - ex) 행렬의 크기, 리스트 원소의 수, 그래프의 정점의 수 등
  - 입력 데이터의 상태
    - 정렬 여부 등

## 점근성능

- `점근 성능` : 입력 크기 n이 무한대로 커짐에 따라 결정되는 성능
- n이 커질수록 상수 및 계수는 성능에 미치는 영향이 줄어든다
- 결국 다항식 함수에서 계수를 제외한 최고차항이 성능에 가장 중요한 영향이고 이를 점근성능으로 결정한다
- 그러므로 수행 시간의 정확한 값이 아닌 어림값이다 -> 그럼 왜 사용하는가?
- 수행 시간의 증가 추세를 파악하는데 용이함 -> 알고리즘의 우열 표현이 용이하기 때문에 사용

## 점근성능의 표기법

점근성능의 표기법에 대해서 알아보자

- `Big-oh 점근적 상한`
  - 함수 f와 g를 각각 양의 정수를 갖는 함수라 하자
  - 이 때 모든 어떤 상수 c와 n0가 존재하여 모든 `n >= n0`에 대하여 `f(n) <= c * g(n)`이면 `f(n) = O(g(n))`이라고 표기한다
  - 즉 Big-oh는 상한을 측정하는 표기법이다
- `Big-omega 점근적 하한`
  - 점근적 상한의 반대 경우이다
  - `Ω(n)`으로 표기한다
- `Big-theta 점근적 상하한`
  - Big-oh(점근적 상항)와 Big-omega(점근적 하한) 를 동시에 표현하는 표기법이다
  - 위와 동일하게 함수 f와 g를 각각 양의 정수를 갖는 함수라 하자
  - 어떤 양의 상수 c1, c2와 n0가 존재하며 모든 `n >= n0`에 대하여 `c * g(n) <= f(n) <= c2 * g(n)` 이면 `f(n) = 𝛉(g(n))` 이라고 표기한다
- 표기법을 계산하는 식들이 복잡하지만 보통 계수를 뺀 최고차항으로 표기한다
- 따라서 `루프의 반복 횟수`를 조사하여 시간복잡도를 표현하게 된다
- ex) n + 2 -> O(n), 이중 for문 -> O(n^2)

## 순환 알고리즘의 성능 (재귀 : recursion)

- 순환(recursion, 재귀) : 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태
- 순환 알고리즘의 성능을 도출하기 위해서는 점화식을 도출해 점화식을 풀어서 점근성능을 표기해야한다

## 분할정복 방법

- 순환적(recursively)으로 문제를 푸는 하향식(top-down) 접근 방법
- 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고
- 이렇게 분할된 작은 문제들을 각각 해결한 후 이 해들을 결합해서 원래 문제의 해를 구하는 방식
- 분할된 작은 문제는 원래 문제와 동일(입력 크기만 작아짐)
- 분할된 작은 문제는 서로 독립적(순환적 분할 및 결과 통합 가능)
- `분할` -> `정복` -> `결합`의 순서로 풀이
- `분할` : 주어진 문제를 여러 개의 작은 문제로 분할
- `정복` : 작은 문제를 순환적으로 분할 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구함
- `결합` : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다(결합 단계가 없는 문제도 존재)
- 알고리즘 예시
  - 이진 탐색, 합병 정렬, 퀵 정렬, 선택 문제

### 이진 탐색

- 정렬된 상태의 입력 데이터에 대해서 효괴적인 탐색 방법
- ex) 오름차순으로 정렬되어 있는 경우
- 탐색을 반복할때마다 대상 원소의 개수가 1/2씩 감소
- 탐색 방법(오름차순으로 정렬된 입력 데이터를 가정)
  - 배열의 가운데 원소 `current`(`A[mid]`)와 탐색키 `x`를 비교
  - `x = current` -> 탐색 성공(인덱스 `mid`반환 후 종료)
  - `x < current` -> 재탐색(원래 크기의 1/2인 왼쪽 부분배열)
  - `x > current` -> 재탐색(원래 크기의 1/2인 오른쪽 부분배열)

### 퀵 정렬

- 특정 원소(피벗)를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
- 오름차순으로 정렬한다고 가정
- `피벗`(pivot) : 주어진 배열을 두 부분배열로 분할할 때 기준이 되는 특정 원소